{ config, lib, pkgs, ... }:
let
  inherit (lib) mkOption types;

  inherit (pkgs) runCommand writeText git;

  processedActionEnvs = map (x: "build --@rules_mojo//mojo:" + x) config.mojoEnv;

  configFile = runCommand ".bazelrc.mojo" { } ''
    printf '# These flags are dynamically generated by rules_mojo.
    #
    # Add try-import %%workspace%%/.bazelrc.mojo to your .bazelrc to
    # include these flags when running Bazel in a nix environment.

    ${lib.concatLines processedActionEnvs}' >$out
  '';
in
{
  options = {
    installationScript = mkOption {
      type = types.str;
      description = lib.mkDoc ''
        A bash snippet which creates a .bazelrc.mojo file in the repository.
      '';
    };
    mojoEnv = mkOption {
      type = types.listOf types.str;
      description = lib.mdDoc ''
        Environment variables for `--@rules_mojo//mojo:*` settings.

        For instance:

        ```nix
        mojoEnv = [
          "MOJO_COMPILER=''${mojo}/bin/mojo"
        ]
        ```

        results in the following line in `.bazelrc.ll`:

        ```bash
        build --@rules_mojo//mojo:MOJO_COMPILER=''${mojo}/bin/mojo
        ```

        Supported values are:

        - `MODULAR_HOME`: The path to the modular/mojo installation directory.
        - `MOJO_COMPILER`: The path to the `mojo` executable.
        - `MOJO_CC_PATH`: Mojo invokes the linker via a C++ compiler. It reads
              the location of this C++ compiler from `PATH`. This variable is
              set internally as the `PATH` for executable compile actions so
              that the linking step invokes the linker via this path.
              # TODO(aaronmondal): Ask upstream whether we can get a dedicated
              # environment variable for this or use `CXX` or `LD` instead.
        - `MOJO_LIBRARY_PATH`: By default, mojo links the following libraries:
              `-lrt,-ldl,-lpthread,-lm,-lz,-ltinfo`. The `libz` and `libtinfo`
              libraries are not in default linker paths, so we add them to the
              linking environment via `LIBRARY_PATH`.
              # TODO(aaronmondal): These libraries are optional in LLVM. Zlib
              # can be substituted by zstd in LLVM. Ask upstream whether they
              # can without `tinfo` and/or change `zlib` to `zstd`.

        Attempting to set any other value will result in Bazel errors.
      '';
      default = { };
    };
  };

  config = {
    installationScript = ''
      if ! type -t git >/dev/null; then
        # In pure shells
        echo 1>&2 "WARNING: rules_mojo: git command not found; skipping installation."
      elif ! ${git}/bin/git rev-parse --git-dir &> /dev/null; then
        echo 1>&2 "WARNING: rules_mojo: .git not found; skipping installation."
      else
        GIT_WC=`${git}/bin/git rev-parse --show-toplevel`

        # These update procedures compare before they write, to avoid
        # filesystem churn. This improves performance with watch tools like
        # lorri and prevents installation loops by lorri.

        if ! readlink "''${GIT_WC}/.bazelrc.mojo" >/dev/null \
          || [[ $(readlink "''${GIT_WC}/.bazelrc.mojo") != ${configFile} ]]; then
          echo 1>&2 "rules_mojo: updating $PWD repository"
          [ -L .bazelrc.mojo ] && unlink .bazelrc.mojo

          if [ -e "''${GIT_WC}/.bazelrc.mojo" ]; then
            echo 1>&2 "rules_mojo: WARNING: Refusing to install because of pre-existing .bazelrc.mojo"
            echo 1>&2 "  Remove the .bazelrc.mojo file and add .bazelrc.mojo to .gitignore."
          else
            ln -fs ${configFile} "''${GIT_WC}/.bazelrc.mojo"
          fi
        fi
      fi
    '';
  };
}
